def PKG_NAME = "unknown"
def PKG_VERSION = "unknown"
def DOC_ZIP_FILENAME = "doc.zip"
def junit_filename = "junit.xml"
def REPORT_DIR = ""
def LOGS_DIR = ""
def BUILD_DIR = ""
def DIST_DIR = ""
def SOURCE_DIR = ""
def VENV_ROOT = ""
def VENV_PYTHON = ""
def VENV_PIP = ""

pipeline {
  agent {
    node{
        label 'Windows && longfilenames && VS2015'
        // customWorkspace "c:/Jenkins/temp/${JOB_NAME}/${BUILD_NUMBER}"

    }
  }
  triggers {
        cron('@daily')
    }
  options {
        disableConcurrentBuilds()  //each branch has 1 job running at a time
        timeout(60)  // Timeout after 60 minutes. This shouldn't take this long but it hangs for some reason
        checkoutToSubdirectory("source")
  }
  environment {
    build_number = VersionNumber(projectStartDate: '2018-6-12', versionNumberString: '${BUILD_DATE_FORMATTED, "yy"}${BUILD_MONTH, XX}${BUILDS_THIS_MONTH, XX}', versionPrefix: '', worstResultForIncrement: 'SUCCESS')
    PIP_CACHE_DIR="${WORKSPACE}\\pipcache\\"
    PIPENV_CACHE_DIR="${WORKSPACE}\\..\\.virtualenvs\\cache\\"
    WORKON_HOME ="${WORKSPACE}\\pipenv\\"
    PATH = "${tool 'cmake3.12'};$PATH"
  }
  parameters {
    booleanParam(name: "FRESH_WORKSPACE", defaultValue: false, description: "Purge workspace before staring and checking out source")
      booleanParam(name: "BUILD_DOCS", defaultValue: true, description: "Build documentation")
      booleanParam(name: "TEST_RUN_PYTEST", defaultValue: true, description: "Run PyTest unit tests")
      booleanParam(name: "TEST_RUN_TOX", defaultValue: true, description: "Run Tox Tests")
      booleanParam(name: "TEST_DOCTEST", defaultValue: true, description: "Run Doctest on the documentation")
      booleanParam(name: "TEST_RUN_MYPY", defaultValue: true, description: "Run MyPy Tests")
      booleanParam(name: "TEST_RUN_FLAKE8", defaultValue: true, description: "Run Flake8 Tests")
      booleanParam(name: "DEPLOY_DEVPI", defaultValue: true, description: "Deploy to devpi on https://devpi.library.illinois.edu/DS_Jenkins/${env.BRANCH_NAME}")
      booleanParam(name: "DEPLOY_DEVPI_PRODUCTION", defaultValue: false, description: "Deploy to production devpi on https://devpi.library.illinois.edu/production/release. Release Branch Only")
      booleanParam(name: "DEPLOY_DOCS", defaultValue: false, description: "Update online documentation. Release Branch Only")
      string(name: 'DEPLOY_DOCS_URL_SUBFOLDER', defaultValue: "imagevalidate", description: 'The directory that the docs should be saved under')
  }

  stages {
    stage('Configure Environment') {
      stages{
        stage("Purge All Existing Data in Workspace"){
            when{
                equals expected: true, actual: params.FRESH_WORKSPACE
            }
            steps{
                deleteDir()
                dir("source"){
                    checkout scm
                }
            }
        }
        stage("Setting Global Job Variables"){

        
          steps {
            // Set up the reports directory variable 
            script{
                REPORT_DIR = "${WORKSPACE}\\reports"
                LOGS_DIR = "${WORKSPACE}\\logs"
                BUILD_DIR = "${WORKSPACE}\\build"
                DIST_DIR = "${WORKSPACE}\\dist"
                SOURCE_DIR = "${WORKSPACE}\\source"
                
            }
          }
          post{
            always{
              echo """Report Directory       = ${REPORT_DIR}
Source directory       = ${SOURCE_DIR}
Logs directory         = ${LOGS_DIR}
Build directory        = ${BUILD_DIR}
Distribution directory = ${DIST_DIR}"""
            }
          }
        }
        
        stage("Cleanup"){
          steps {
            dir("${LOGS_DIR}"){
              deleteDir()
              bat "dir"
            }
            

            dir("${BUILD_DIR}"){
              deleteDir()
            }

            dir("${DIST_DIR}"){
              deleteDir()
              // echo "Cleaned out distrubution directory"
              // bat "dir"
            }

            dir("${REPORT_DIR}"){
              deleteDir()
              echo "Cleaned out reports directory"
              bat "dir"
            }
          }
        }
        stage("Installing required system level dependencies"){
          steps{
            lock("system_python_${NODE_NAME}"){
              bat "${tool 'CPython-3.6'} -m pip install --upgrade pip"
            }
            tee("${LOGS_DIR}/pippackages_system_${NODE_NAME}.log") {
                bat "${tool 'CPython-3.6'} -m pip list"
            }
          }
          post{
            always{
                dir("${LOGS_DIR}"){
                    script{
                        def log_files = findFiles glob: '**/pippackages_system_*.log'
                        log_files.each { log_file ->
                            echo "Found ${log_file}"
                            archiveArtifacts artifacts: "${log_file}"
                            bat "del ${log_file}"
                        }
                    }
                }
            }
            failure {
                deleteDir()
            }
          }
        }
        stage("Setting Project Metadata Variables"){
          steps{      
            script {
              dir("${SOURCE_DIR}"){
                PKG_NAME = bat(returnStdout: true, script: "@${tool 'CPython-3.6'}  setup.py --name").trim()
                PKG_VERSION = bat(returnStdout: true, script: "@${tool 'CPython-3.6'} setup.py --version").trim()
              }
      
              // Multibranch jobs add the slash and add the branch to the job name. I need only the job name
              def alljob = env.JOB_NAME.tokenize("/") as String[]
              def project_name = alljob[0]
              DOC_ZIP_FILENAME = "${PKG_NAME}-${PKG_VERSION}.doc.zip"
              
              junit_filename = "junit-${env.NODE_NAME}-${env.GIT_COMMIT.substring(0,7)}-pytest.xml"
            }
          }
          post{
            always{
              echo """Name                   = ${PKG_NAME}
Version                = ${PKG_VERSION}
documentation zip file = ${DOC_ZIP_FILENAME}"""
              
            } 
          }
        }

        // tee("${LOGS_DIR}/pippackages_system_${NODE_NAME}.log") {
        //   bat "${tool 'CPython-3.6'} -m pip list"
        // }
        stage("Installing Pipfile"){
          options{
            timeout(5)
          }
          steps {
            dir("source"){
              bat "pipenv install --dev --deploy"
            }
            tee("logs/pippackages_pipenv_${NODE_NAME}.log") {
              dir("source"){
                bat "pipenv run pip list"
              }
            }  
          }
          post{
            always{
              dir("logs"){
                script{
                  def log_files = findFiles glob: '**/pippackages_pipenv_*.log'
                  log_files.each { log_file ->
                    echo "Found ${log_file}"
                    archiveArtifacts artifacts: "${log_file}"
                    bat "del ${log_file}"
                  }
                }
              }
            }
          }
        }
        stage("Creating Virtualenv for Building"){
          steps {
              bat "${tool 'CPython-3.6'} -m venv venv"
              
              script {
                  try {
                      bat "call venv\\Scripts\\python.exe -m pip install -U pip"
                  }
                  catch (exc) {
                      bat "${tool 'CPython-3.6'} -m venv venv"
                      bat "call venv\\Scripts\\python.exe -m pip install -U pip --no-cache-dir"
                  }                           
              }
              bat "venv\\Scripts\\pip.exe install devpi-client pytest --upgrade-strategy only-if-needed"
              
  
              tee("${WORKSPACE}/logs/pippackages_venv_${NODE_NAME}.log") {
                  bat "venv\\Scripts\\pip.exe list"
              }
              script {
                VENV_ROOT = "${WORKSPACE}\\venv"
                
                // set python exe
                VENV_PYTHON = "${WORKSPACE}\\venv\\Scripts\\python.exe"
                bat "${VENV_PYTHON} --version"

                VENV_PIP = "${WORKSPACE}\\venv\\Scripts\\pip.exe"
                bat "${VENV_PIP} --version"
              }
          }
          post{
            always{
              script{
                  def log_files = findFiles glob: '**/pippackages_venv_*.log'
                  log_files.each { log_file ->
                      echo "Found ${log_file}"
                      archiveArtifacts artifacts: "${log_file}"
                      bat "del ${log_file}"
                  }
              }
              echo """Python virtual environment path = ${VENV_ROOT}
VirtualEnv Python executable    = ${VENV_PYTHON}
VirtualEnv Pip executable       = ${VENV_PIP}"""
            }
            failure {
              deleteDir()
            }
          }
        }
            // bat "${tool 'CPython-3.6'} -m venv venv"
            

            // script {
            //     try {
            //         bat "call venv\\Scripts\\activate.bat && python -m pip install -U pip"
            //     }
            //     catch (exc) {
            //         bat "${tool 'CPython-3.6'} -m venv venv"
            //         bat "call venv\\Scripts\\activate.bat && python -m pip install -U pip --no-cache-dir"
            //     }
                

            // }
            // bat "${tool 'CPython-3.6'} -m venv venv"
            // bat "${VENV_PIP} install devpi-client -r ${SOURCE_DIR}\\requirements.txt --upgrade-strategy only-if-needed"

            // bat "${VENV_PYTHON} -m pip install devpi-client tox lxml mypy flake8 sphinx wheel"

            // tee("${LOGS_DIR}/pippackages_venv_${NODE_NAME}.log") {
            //   bat "${VENV_PIP} list"
            // }
        stage("Configure DevPi Login"){
          steps{    
            bat "${VENV_ROOT}\\Scripts\\devpi use https://devpi.library.illinois.edu"
            withCredentials([usernamePassword(credentialsId: 'DS_devpi', usernameVariable: 'DEVPI_USERNAME', passwordVariable: 'DEVPI_PASSWORD')]) {    
              bat "${VENV_ROOT}\\Scripts\\devpi.exe login ${DEVPI_USERNAME} --password ${DEVPI_PASSWORD}"
            }
          }
        }
        
        // }
        // }
        
      }
      post{
        failure {
            bat "dir"
            deleteDir()
        }
      }
    }
    stage("Build"){
      steps {
        tee("${LOGS_DIR}/build.log") {
          dir("${SOURCE_DIR}"){
            bat script: "pipenv run python setup.py build -b ${BUILD_DIR} --build-lib ${BUILD_DIR}\\lib -j${env.NUMBER_OF_PROCESSORS} -t ${BUILD_DIR}\\temp build_ext --inplace"
          }
        }
      }
      post{
        always{

          dir("${LOGS_DIR}"){
            warnings canRunOnFailed: true, parserConfigurations: [[parserName: 'Pep8', pattern: "build.log"]]
            archiveArtifacts artifacts: "*.log"
          }

        }
      }
    }
    stage("Sphinx Documentation"){
      steps {
        echo "Building docs on ${env.NODE_NAME}"
        script{
            // Add a line to config file so auto docs look in the build folder
            def sphinx_config_file = "${SOURCE_DIR}/docs/source/conf.py"
            def extra_line = "sys.path.insert(0, os.path.abspath('${BUILD_DIR}/build/lib'))"
            def readContent = readFile "${sphinx_config_file}"
            echo "Adding \"${extra_line}\" to ${sphinx_config_file}."
            writeFile file: "${sphinx_config_file}", text: readContent+"\r\n${extra_line}\r\n"
        }
        tee("${LOGS_DIR}/build_sphinx.log") {
           dir("source"){
                bat "pipenv run sphinx-build -b html ${SOURCE_DIR}\\docs\\source ${BUILD_DIR}\\docs\\html -d ${BUILD_DIR}\\docs\\doctrees"
            // bat "${VENV_ROOT}\\Scripts\\sphinx-build.exe -b html ${SOURCE_DIR}\\docs\\source ${BUILD_DIR}\\docs\\html -d ${BUILD_DIR}\\docs\\doctrees"
           }
        }
      }
      post{
        always {
          
          dir("${LOGS_DIR}"){
            warnings canRunOnFailed: true, parserConfigurations: [[parserName: 'Sphinx-build', pattern: "build_sphinx.log"]]
            archiveArtifacts artifacts: "build_sphinx.log"
          }
          
        }
        success{
          publishHTML([allowMissing: false, alwaysLinkToLastBuild: false, keepAll: false, reportDir: "${BUILD_DIR}/docs/html", reportFiles: 'index.html', reportName: 'Documentation', reportTitles: ''])
          script{
            // // Multibranch jobs add the slash and add the branch to the job name. I need only the job name
            // def alljob = env.JOB_NAME.tokenize("/") as String[]
            // def project_name = alljob[0]
            dir("${DIST_DIR}"){
              zip archive: true, dir: "${BUILD_DIR}/docs/html", glob: '', zipFile: "${DOC_ZIP_FILENAME}"
            } 
          }
        }
        failure{
            echo "Failed to build Python package"
        }
      }
    }
  
    stage('Test') {
      parallel {
        stage("Tox") {
          when {
            equals expected: true, actual: params.TEST_RUN_TOX
          }
          steps {
            dir("${REPORT_DIR}\\coverage\\"){
              bat "dir"
            }
            dir("source"){
              script {
                // bat "pipenv run tox --workdir ${WORKSPACE}\\.tox\\PyTest -v -- --integration --junitxml=${REPORT_DIR}\\${junit_filename} --junit-prefix=${env.NODE_NAME}-pytest --cov-report html:${REPORT_DIR}\\coverage\\ --cov=uiucprescon.imagevalidate"
                try{
                    bat "pipenv run tox --workdir ..\\.tox\\PyTest"
//                  bat "pipenv run tox -vv --workdir ${WORKSPACE}\\.tox\\PyTest -- --junitxml=${REPORT_DIR}\\${junit_filename} --junit-prefix=${env.NODE_NAME}-pytest --cov-report html:${REPORT_DIR}/coverage/ --cov=ocr"
                } catch (exc) {
                    bat "pipenv run tox -vv --recreate --workdir ..\\.tox\\PyTest"
                }
                
              }
            }
            
          }
//          post{
//            always{
//              dir("${REPORT_DIR}"){
//                bat "dir"
//                script {
//                  def xml_files = findFiles glob: "**/*.xml"
//                  xml_files.each { junit_xml_file ->
//                    echo "Found ${junit_xml_file}"
//                    junit "${junit_xml_file}"
//                  }
//                }
//              }
//              publishHTML([allowMissing: true, alwaysLinkToLastBuild: false, keepAll: false, reportDir: "${REPORT_DIR}/coverage", reportFiles: 'index.html', reportName: 'Coverage', reportTitles: ''])
//            }
//          }
        }
        stage("Run PyTest Unit Tests"){
            when {
               equals expected: true, actual: params.TEST_RUN_PYTEST
            }
            environment{
                junit_filename = "junit-${env.NODE_NAME}-${env.GIT_COMMIT.substring(0,7)}-pytest.xml"
            }
            steps{
                dir("source"){
                    bat "pipenv run python -m pytest --junitxml=${WORKSPACE}/reports/pytest/${junit_filename} --junit-prefix=${env.NODE_NAME}-pytest --cov-report html:${WORKSPACE}/reports/pytestcoverage/  --cov-report xml:${WORKSPACE}/reports/coverage.xml --cov=uiucprescon --integration --cov-config=${WORKSPACE}/source/setup.cfg"
                }
            }
            post {
                always {
                    publishHTML([allowMissing: false, alwaysLinkToLastBuild: false, keepAll: false, reportDir: "reports/pytestcoverage", reportFiles: 'index.html', reportName: 'Coverage.py', reportTitles: ''])
                    junit "reports/pytest/${junit_filename}"
                    script {
                        try{
                            publishCoverage
                                autoDetectPath: 'coverage*/*.xml'
                                adapters: [
                                    cobertura(coberturaReportFile:"reports/coverage.xml")
                                ]
                        } catch(exc){
                            echo "cobertura With Coverage API failed. Falling back to cobertura plugin"
                            cobertura autoUpdateHealth: false, autoUpdateStability: false, coberturaReportFile: "reports/coverage.xml", conditionalCoverageTargets: '70, 0, 0', failUnhealthy: false, failUnstable: false, lineCoverageTargets: '80, 0, 0', maxNumberOfBuilds: 0, methodCoverageTargets: '80, 0, 0', onlyStable: false, sourceEncoding: 'ASCII', zoomCoverageChart: false
                        }
                    }
                    bat "del reports\\coverage.xml"

                }

            }
        }
        stage("Run Doctest Tests"){
          when {
            equals expected: true, actual: params.TEST_DOCTEST
          }
          steps {
            dir("${SOURCE_DIR}"){
              dir("${REPORT_DIR}/doctests"){
                echo "Cleaning doctest reports directory"
                deleteDir()
              }
              bat "pipenv run sphinx-build -b doctest docs\\source ${BUILD_DIR}\\docs -d ${BUILD_DIR}\\docs\\doctrees -v" 
            }
            bat "move ${BUILD_DIR}\\docs\\output.txt ${REPORT_DIR}\\doctest.txt"
          }
          post{
            always {
              dir("${REPORT_DIR}"){
                archiveArtifacts artifacts: "doctest.txt"
              }
            }
          }
        }
        stage("Run MyPy Static Analysis") {
          when {
            equals expected: true, actual: params.TEST_RUN_MYPY
          }
          steps{
            dir("${REPORT_DIR}/mypy/html"){
              deleteDir()
              bat "dir"
            }
            script{
              tee("${LOGS_DIR}/mypy.log") {
                try{
                  dir("${SOURCE_DIR}"){
                    bat "dir"
                    bat "pipenv run mypy -p uiucprescon --html-report ${REPORT_DIR}\\mypy\\html"
                  }
                } catch (exc) {
                  echo "MyPy found some warnings"
                }
              }
            }
          }
          post {
            always {
              dir("${LOGS_DIR}"){
                warnings canRunOnFailed: true, parserConfigurations: [[parserName: 'MyPy', pattern: "mypy.log"]], unHealthy: ''
              }
              publishHTML([allowMissing: false, alwaysLinkToLastBuild: false, keepAll: false, reportDir: "${REPORT_DIR}/mypy/html/", reportFiles: 'index.html', reportName: 'MyPy HTML Report', reportTitles: ''])
            }
          }
        }
        stage("Flake8") {
          when {
              equals expected: true, actual: params.TEST_RUN_FLAKE8
          }
          steps{
            script{
              try{
                tee("${LOGS_DIR}/flake8.log") {
                  dir("source"){
                    bat "pipenv run flake8 uiucprescon --format=pylint"
                  }
                }
              } catch (exc) {
                echo "flake8 found some warnings"
              }
            }
          }
          post {
            always {
              dir("${LOGS_DIR}"){
                warnings parserConfigurations: [[parserName: 'PyLint', pattern: 'flake8.log']], unHealthy: ''
                archiveArtifacts artifacts: 'flake8.log', fingerprint: true
              }
              
            }
          }
        }
      }
    }
    stage('Package') {
      steps {
        dir("${SOURCE_DIR}"){

          // bat "${WORKSPACE}\\venv\\Scripts\\python.exe setup.py bdist_wheel sdist"
          bat "pipenv run python setup.py build -b ${BUILD_DIR} --build-lib ${BUILD_DIR}\\lib -j${env.NUMBER_OF_PROCESSORS} -t ${BUILD_DIR}\\temp sdist -d ${DIST_DIR} bdist_wheel -d ${DIST_DIR}"
        }
      }
      post{
        success {
          dir("${DIST_DIR}") {
            archiveArtifacts artifacts: '*.whl', fingerprint: true
            archiveArtifacts artifacts: '*.zip', fingerprint: true
            archiveArtifacts artifacts: '*.tar.gz', fingerprint: true
          }
        }
      }
    }
    stage("Deploying to DevPi Staging") {
      when {
        expression { params.DEPLOY_DEVPI == true && (env.BRANCH_NAME == "master" || env.BRANCH_NAME == "dev")}
      }
      steps {
        bat "${VENV_ROOT}\\Scripts\\devpi.exe use https://devpi.library.illinois.edu"
        withCredentials([usernamePassword(credentialsId: 'DS_devpi', usernameVariable: 'DEVPI_USERNAME', passwordVariable: 'DEVPI_PASSWORD')]) {
          bat "${VENV_ROOT}\\Scripts\\devpi.exe login ${DEVPI_USERNAME} --password ${DEVPI_PASSWORD}"
          bat "${VENV_ROOT}\\Scripts\\devpi.exe use /${DEVPI_USERNAME}/${env.BRANCH_NAME}_staging"
          dir("${SOURCE_DIR}"){
            script {
              bat "${VENV_ROOT}\\Scripts\\devpi.exe upload --from-dir ${DIST_DIR} --verbose"
              try {
                bat "${VENV_ROOT}\\Scripts\\devpi.exe upload --only-docs ${DIST_DIR}\\${DOC_ZIP_FILENAME}"
              } catch (exc) {
                echo "Unable to upload to devpi with docs."
              }
            }
          }
        }
      }
    }
    stage("Test DevPi Packages") {
      when {
          expression { params.DEPLOY_DEVPI == true  && (env.BRANCH_NAME == "master" || env.BRANCH_NAME == "dev")}
      }
      parallel {
        stage("Source Distribution: .tar.gz") {
              agent {
                node {
                  label "Windows && Python3 && VS2015"
                }
              }
              options {
                skipDefaultCheckout(true)
              }
              stages{
                    stage("Setting up DevPi Test Environment for sdist tar.gz"){
                        steps{
                            echo "Testing Source tar.gz package for DevPi"

                            bat "${tool 'CPython-3.6'} -m venv venv"
                            bat "venv\\Scripts\\pip.exe install tox devpi-client"
                            withCredentials([usernamePassword(credentialsId: 'DS_devpi', usernameVariable: 'DEVPI_USERNAME', passwordVariable: 'DEVPI_PASSWORD')]) {
                              bat "venv\\Scripts\\devpi.exe login ${DEVPI_USERNAME} --password ${DEVPI_PASSWORD}"
                            }
                            bat "venv\\Scripts\\devpi.exe use /DS_Jenkins/${env.BRANCH_NAME}_staging"
                        }
                    }
                    stage("Testing sdist tar.gz DevPi package"){
                        steps {
                            bat script: "venv\\Scripts\\devpi.exe test --index https://devpi.library.illinois.edu/DS_Jenkins/${env.BRANCH_NAME}_staging ${PKG_NAME} -s tar.gz  --verbose"
                        }
                    }
              }
        }
        stage("Source Distribution: .zip") {
              agent {
                    node {
                        label "Windows && Python3 && VS2015"
                    }
              }
              options {
                skipDefaultCheckout(true)
              }
              stages{
                    stage("Setting up DevPi Test Environment for sdist zip"){
                        steps {
                            echo "Testing Source zip package for DevPi"
                            bat "${tool 'CPython-3.6'} -m venv venv"
                            bat "venv\\Scripts\\pip.exe install tox devpi-client"
                            withCredentials([usernamePassword(credentialsId: 'DS_devpi', usernameVariable: 'DEVPI_USERNAME', passwordVariable: 'DEVPI_PASSWORD')]) {
                              bat "venv\\Scripts\\devpi.exe login ${DEVPI_USERNAME} --password ${DEVPI_PASSWORD}"
                            }
                            bat "venv\\Scripts\\devpi.exe use /DS_Jenkins/${env.BRANCH_NAME}_staging"
                        }

                    }
                    stage("Testing sdist zip DevPi package"){
                        steps{
                            bat script: "venv\\Scripts\\devpi.exe test --index https://devpi.library.illinois.edu/DS_Jenkins/${env.BRANCH_NAME}_staging ${PKG_NAME} -s zip --verbose"
                        }
                        post {
                            failure {
                                echo "Tests for .zip source on DevPi failed."
                            }
                        }
                    }
              }

        }
        stage("Built Distribution: .whl") {
              agent {
                    node {
                        label "Windows && Python3"
                    }
              }
              options{
                skipDefaultCheckout(true)
              }
              stages{
                    stage("Setting up DevPi Test Environment for bdist wheel"){
                          steps {
                                script {
                                    bat "${tool 'CPython-3.6'} -m venv venv"
                                    bat "venv\\Scripts\\pip.exe install tox devpi-client"
                                    bat "venv\\Scripts\\devpi.exe use https://devpi.library.illinois.edu"
                                    withCredentials([usernamePassword(credentialsId: 'DS_devpi', usernameVariable: 'DEVPI_USERNAME', passwordVariable: 'DEVPI_PASSWORD')]) {
                                      bat "venv\\Scripts\\devpi.exe login ${DEVPI_USERNAME} --password ${DEVPI_PASSWORD}"
                                      bat "venv\\Scripts\\devpi.exe use /${DEVPI_USERNAME}/${env.BRANCH_NAME}_staging"
                                    }
                                }
                          }

                    }
                    stage("Testing bdist wheel DevPi package"){
                        steps{
                            bat "venv\\Scripts\\devpi.exe test --index https://devpi.library.illinois.edu/DS_Jenkins/${env.BRANCH_NAME}_staging ${PKG_NAME} -s whl --verbose"
                        }

                    }
              }
              post{
                    failure{
                        echo "whl failed test on ${env.NODE_NAME}"
                    }

              }


        }
      }
      post {
        success {
          echo "It Worked. Pushing file to ${env.BRANCH_NAME} index"
          script {
            withCredentials([usernamePassword(credentialsId: 'DS_devpi', usernameVariable: 'DEVPI_USERNAME', passwordVariable: 'DEVPI_PASSWORD')]) {
              bat "${VENV_ROOT}\\Scripts\\devpi.exe login ${DEVPI_USERNAME} --password ${DEVPI_PASSWORD}"
              bat "${VENV_ROOT}\\Scripts\\devpi.exe use /${DEVPI_USERNAME}/${env.BRANCH_NAME}_staging"
              bat "${VENV_ROOT}\\Scripts\\devpi.exe push ${PKG_NAME}==${PKG_VERSION} ${DEVPI_USERNAME}/${env.BRANCH_NAME}"
            }
          }
        }
      }

    }
    stage("Release") {
      parallel {
        stage("Release to DevPi Production") {
          when {
            allOf{
              equals expected: true, actual: params.DEPLOY_DEVPI_PRODUCTION
              branch "master"
            }
          }
          steps{
            input "Release ${PKG_NAME} ${PKG_VERSION} to DevPi Production?"
            // script {
            withCredentials([usernamePassword(credentialsId: 'DS_devpi', usernameVariable: 'DEVPI_USERNAME', passwordVariable: 'DEVPI_PASSWORD')]) {
              bat "${VENV_ROOT}\\Scripts\\devpi.exe login ${DEVPI_USERNAME} --password ${DEVPI_PASSWORD}"
            }
            // }
            bat "${VENV_ROOT}\\Scripts\\devpi.exe use /DS_Jenkins/${env.BRANCH_NAME}_staging"
            bat "${VENV_ROOT}\\Scripts\\devpi.exe push ${PKG_NAME}==${PKG_VERSION} production/release"
          }
        }
        stage("Deploy Online Documentation") {
          when {
            allOf{
              equals expected: true, actual: params.DEPLOY_DOCS
              branch "master"
            }
          }
          steps {
            dir("${BUILD_DIR}/docs/html/"){
              input 'Update project documentation?'
              sshPublisher(
                publishers: [
                  sshPublisherDesc(
                    configName: 'apache-ns - lib-dccuser-updater', 
                    sshLabel: [label: 'Linux'], 
                    transfers: [sshTransfer(excludes: '', 
                    execCommand: '', 
                    execTimeout: 120000, 
                    flatten: false, 
                    makeEmptyDirs: false, 
                    noDefaultExcludes: false, 
                    patternSeparator: '[, ]+', 
                    remoteDirectory: "${params.DEPLOY_DOCS_URL_SUBFOLDER}", 
                    remoteDirectorySDF: false, 
                    removePrefix: '', 
                    sourceFiles: '**')], 
                  usePromotionTimestamp: false, 
                  useWorkspaceInPromotion: false, 
                  verbose: true
                  )
                ]
              )
            }
          }
        }
      }
    }
  }
  post {
    cleanup {
      
      dir("${DIST_DIR}") {
        deleteDir()
      }

      dir("${BUILD_DIR}") {
        deleteDir()
      }
      script {
        if(fileExists("${SOURCE_DIR}/setup.py")){
          dir("${SOURCE_DIR}"){
            try{
              bat "${VENV_PYTHON} setup.py clean --all"
            } catch (Exception ex) {
              // echo "Unable to succesfully run clean. Purging source directory."
              deleteDir()
            }
            bat "dir"
          }
        }
//        remove any shared library built in place
        dir("${SOURCE_DIR}"){
            def generated_c_libraries = findFiles glob: '**/*.dll,**/*.pyd,**.so,**/*.dylib'
            generated_c_libraries .each { c_library ->
                echo "Deleting ${pwd()}/${c_library}"
    //            bat "del ${log_file}"
            }
        }

        if (env.BRANCH_NAME == "master" || env.BRANCH_NAME == "dev"){
          withCredentials([usernamePassword(credentialsId: 'DS_devpi', usernameVariable: 'DEVPI_USERNAME', passwordVariable: 'DEVPI_PASSWORD')]) {
            bat "${VENV_ROOT}\\Scripts\\devpi.exe login DS_Jenkins --password ${DEVPI_PASSWORD}"
            bat "${VENV_ROOT}\\Scripts\\devpi.exe use /DS_Jenkins/${env.BRANCH_NAME}_staging"
          }

          def devpi_remove_return_code = bat returnStatus: true, script:"${VENV_ROOT}\\Scripts\\devpi.exe remove -y ${PKG_NAME}==${PKG_VERSION}"
          echo "Devpi remove exited with code ${devpi_remove_return_code}."
        }
      }
      bat "dir"
    }
  }
}